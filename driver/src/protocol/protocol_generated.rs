// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protocol {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum PacketOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Packet<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Packet<'a> {
        type Inner = Packet<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Packet<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_PROCESS_ID: flatbuffers::VOffsetT = 6;
        pub const VT_PROCESS_PATH: flatbuffers::VOffsetT = 8;
        pub const VT_DIRECTION: flatbuffers::VOffsetT = 10;
        pub const VT_IP_V6: flatbuffers::VOffsetT = 12;
        pub const VT_PROTOCOL: flatbuffers::VOffsetT = 14;
        pub const VT_LOCAL_IP: flatbuffers::VOffsetT = 16;
        pub const VT_REMOTE_IP: flatbuffers::VOffsetT = 18;
        pub const VT_LOCAL_PORT: flatbuffers::VOffsetT = 20;
        pub const VT_REMOTE_PORT: flatbuffers::VOffsetT = 22;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Packet { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PacketArgs<'args>,
        ) -> flatbuffers::WIPOffset<Packet<'bldr>> {
            let mut builder = PacketBuilder::new(_fbb);
            if let Some(x) = args.process_id {
                builder.add_process_id(x);
            }
            if let Some(x) = args.remote_ip {
                builder.add_remote_ip(x);
            }
            if let Some(x) = args.local_ip {
                builder.add_local_ip(x);
            }
            if let Some(x) = args.process_path {
                builder.add_process_path(x);
            }
            builder.add_id(args.id);
            builder.add_remote_port(args.remote_port);
            builder.add_local_port(args.local_port);
            builder.add_protocol(args.protocol);
            builder.add_ip_v6(args.ip_v6);
            builder.add_direction(args.direction);
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Packet::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn process_id(&self) -> Option<u64> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Packet::VT_PROCESS_ID, None) }
        }
        #[inline]
        pub fn process_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Packet::VT_PROCESS_PATH, None)
            }
        }
        #[inline]
        pub fn direction(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Packet::VT_DIRECTION, Some(0)).unwrap() }
        }
        #[inline]
        pub fn ip_v6(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Packet::VT_IP_V6, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn protocol(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Packet::VT_PROTOCOL, Some(0)).unwrap() }
        }
        #[inline]
        pub fn local_ip(&self) -> Option<flatbuffers::Vector<'a, u32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        Packet::VT_LOCAL_IP,
                        None,
                    )
            }
        }
        #[inline]
        pub fn remote_ip(&self) -> Option<flatbuffers::Vector<'a, u32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        Packet::VT_REMOTE_IP,
                        None,
                    )
            }
        }
        #[inline]
        pub fn local_port(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u16>(Packet::VT_LOCAL_PORT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn remote_port(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u16>(Packet::VT_REMOTE_PORT, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Packet<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<u64>("process_id", Self::VT_PROCESS_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "process_path",
                    Self::VT_PROCESS_PATH,
                    false,
                )?
                .visit_field::<u8>("direction", Self::VT_DIRECTION, false)?
                .visit_field::<bool>("ip_v6", Self::VT_IP_V6, false)?
                .visit_field::<u8>("protocol", Self::VT_PROTOCOL, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                    "local_ip",
                    Self::VT_LOCAL_IP,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                    "remote_ip",
                    Self::VT_REMOTE_IP,
                    false,
                )?
                .visit_field::<u16>("local_port", Self::VT_LOCAL_PORT, false)?
                .visit_field::<u16>("remote_port", Self::VT_REMOTE_PORT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PacketArgs<'a> {
        pub id: u32,
        pub process_id: Option<u64>,
        pub process_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub direction: u8,
        pub ip_v6: bool,
        pub protocol: u8,
        pub local_ip: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        pub remote_ip: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        pub local_port: u16,
        pub remote_port: u16,
    }
    impl<'a> Default for PacketArgs<'a> {
        #[inline]
        fn default() -> Self {
            PacketArgs {
                id: 0,
                process_id: None,
                process_path: None,
                direction: 0,
                ip_v6: false,
                protocol: 0,
                local_ip: None,
                remote_ip: None,
                local_port: 0,
                remote_port: 0,
            }
        }
    }

    pub struct PacketBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PacketBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(Packet::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_process_id(&mut self, process_id: u64) {
            self.fbb_
                .push_slot_always::<u64>(Packet::VT_PROCESS_ID, process_id);
        }
        #[inline]
        pub fn add_process_path(&mut self, process_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Packet::VT_PROCESS_PATH,
                process_path,
            );
        }
        #[inline]
        pub fn add_direction(&mut self, direction: u8) {
            self.fbb_
                .push_slot::<u8>(Packet::VT_DIRECTION, direction, 0);
        }
        #[inline]
        pub fn add_ip_v6(&mut self, ip_v6: bool) {
            self.fbb_.push_slot::<bool>(Packet::VT_IP_V6, ip_v6, false);
        }
        #[inline]
        pub fn add_protocol(&mut self, protocol: u8) {
            self.fbb_.push_slot::<u8>(Packet::VT_PROTOCOL, protocol, 0);
        }
        #[inline]
        pub fn add_local_ip(
            &mut self,
            local_ip: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Packet::VT_LOCAL_IP, local_ip);
        }
        #[inline]
        pub fn add_remote_ip(
            &mut self,
            remote_ip: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Packet::VT_REMOTE_IP, remote_ip);
        }
        #[inline]
        pub fn add_local_port(&mut self, local_port: u16) {
            self.fbb_
                .push_slot::<u16>(Packet::VT_LOCAL_PORT, local_port, 0);
        }
        #[inline]
        pub fn add_remote_port(&mut self, remote_port: u16) {
            self.fbb_
                .push_slot::<u16>(Packet::VT_REMOTE_PORT, remote_port, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PacketBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Packet<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Packet<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Packet");
            ds.field("id", &self.id());
            ds.field("process_id", &self.process_id());
            ds.field("process_path", &self.process_path());
            ds.field("direction", &self.direction());
            ds.field("ip_v6", &self.ip_v6());
            ds.field("protocol", &self.protocol());
            ds.field("local_ip", &self.local_ip());
            ds.field("remote_ip", &self.remote_ip());
            ds.field("local_port", &self.local_port());
            ds.field("remote_port", &self.remote_port());
            ds.finish()
        }
    }
} // pub mod Protocol
