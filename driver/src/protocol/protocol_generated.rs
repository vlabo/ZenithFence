// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protocol {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INFO_UNION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INFO_UNION: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INFO_UNION: [InfoUnion; 3] = [
  InfoUnion::NONE,
  InfoUnion::Packet,
  InfoUnion::LogLine,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct InfoUnion(pub u8);
#[allow(non_upper_case_globals)]
impl InfoUnion {
  pub const NONE: Self = Self(0);
  pub const Packet: Self = Self(1);
  pub const LogLine: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Packet,
    Self::LogLine,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Packet => Some("Packet"),
      Self::LogLine => Some("LogLine"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for InfoUnion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for InfoUnion {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for InfoUnion {
    type Output = InfoUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for InfoUnion {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for InfoUnion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for InfoUnion {}
pub struct InfoUnionUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMMAND_UNION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMMAND_UNION: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMMAND_UNION: [CommandUnion; 3] = [
  CommandUnion::NONE,
  CommandUnion::Response,
  CommandUnion::Shutdown,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CommandUnion(pub u8);
#[allow(non_upper_case_globals)]
impl CommandUnion {
  pub const NONE: Self = Self(0);
  pub const Response: Self = Self(1);
  pub const Shutdown: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Response,
    Self::Shutdown,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Response => Some("Response"),
      Self::Shutdown => Some("Shutdown"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CommandUnion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CommandUnion {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CommandUnion {
    type Output = CommandUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CommandUnion {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CommandUnion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CommandUnion {}
pub struct CommandUnionUnionTableOffset {}

pub enum PacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Packet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Packet<'a> {
  type Inner = Packet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Packet<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROCESS_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PROCESS_PATH: flatbuffers::VOffsetT = 8;
  pub const VT_DIRECTION: flatbuffers::VOffsetT = 10;
  pub const VT_IP_V6: flatbuffers::VOffsetT = 12;
  pub const VT_PROTOCOL: flatbuffers::VOffsetT = 14;
  pub const VT_LOCAL_IP: flatbuffers::VOffsetT = 16;
  pub const VT_REMOTE_IP: flatbuffers::VOffsetT = 18;
  pub const VT_LOCAL_PORT: flatbuffers::VOffsetT = 20;
  pub const VT_REMOTE_PORT: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Packet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PacketArgs<'args>
  ) -> flatbuffers::WIPOffset<Packet<'bldr>> {
    let mut builder = PacketBuilder::new(_fbb);
    if let Some(x) = args.process_id { builder.add_process_id(x); }
    builder.add_id(args.id);
    if let Some(x) = args.remote_ip { builder.add_remote_ip(x); }
    if let Some(x) = args.local_ip { builder.add_local_ip(x); }
    if let Some(x) = args.process_path { builder.add_process_path(x); }
    builder.add_remote_port(args.remote_port);
    builder.add_local_port(args.local_port);
    builder.add_protocol(args.protocol);
    builder.add_ip_v6(args.ip_v6);
    builder.add_direction(args.direction);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Packet::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn process_id(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Packet::VT_PROCESS_ID, None)}
  }
  #[inline]
  pub fn process_path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Packet::VT_PROCESS_PATH, None)}
  }
  #[inline]
  pub fn direction(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Packet::VT_DIRECTION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ip_v6(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Packet::VT_IP_V6, Some(false)).unwrap()}
  }
  #[inline]
  pub fn protocol(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Packet::VT_PROTOCOL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn local_ip(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Packet::VT_LOCAL_IP, None)}
  }
  #[inline]
  pub fn remote_ip(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Packet::VT_REMOTE_IP, None)}
  }
  #[inline]
  pub fn local_port(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Packet::VT_LOCAL_PORT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn remote_port(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Packet::VT_REMOTE_PORT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Packet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<u64>("process_id", Self::VT_PROCESS_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("process_path", Self::VT_PROCESS_PATH, false)?
     .visit_field::<u8>("direction", Self::VT_DIRECTION, false)?
     .visit_field::<bool>("ip_v6", Self::VT_IP_V6, false)?
     .visit_field::<u8>("protocol", Self::VT_PROTOCOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("local_ip", Self::VT_LOCAL_IP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("remote_ip", Self::VT_REMOTE_IP, false)?
     .visit_field::<u16>("local_port", Self::VT_LOCAL_PORT, false)?
     .visit_field::<u16>("remote_port", Self::VT_REMOTE_PORT, false)?
     .finish();
    Ok(())
  }
}
pub struct PacketArgs<'a> {
    pub id: u64,
    pub process_id: Option<u64>,
    pub process_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub direction: u8,
    pub ip_v6: bool,
    pub protocol: u8,
    pub local_ip: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub remote_ip: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub local_port: u16,
    pub remote_port: u16,
}
impl<'a> Default for PacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    PacketArgs {
      id: 0,
      process_id: None,
      process_path: None,
      direction: 0,
      ip_v6: false,
      protocol: 0,
      local_ip: None,
      remote_ip: None,
      local_port: 0,
      remote_port: 0,
    }
  }
}

pub struct PacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Packet::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_process_id(&mut self, process_id: u64) {
    self.fbb_.push_slot_always::<u64>(Packet::VT_PROCESS_ID, process_id);
  }
  #[inline]
  pub fn add_process_path(&mut self, process_path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Packet::VT_PROCESS_PATH, process_path);
  }
  #[inline]
  pub fn add_direction(&mut self, direction: u8) {
    self.fbb_.push_slot::<u8>(Packet::VT_DIRECTION, direction, 0);
  }
  #[inline]
  pub fn add_ip_v6(&mut self, ip_v6: bool) {
    self.fbb_.push_slot::<bool>(Packet::VT_IP_V6, ip_v6, false);
  }
  #[inline]
  pub fn add_protocol(&mut self, protocol: u8) {
    self.fbb_.push_slot::<u8>(Packet::VT_PROTOCOL, protocol, 0);
  }
  #[inline]
  pub fn add_local_ip(&mut self, local_ip: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Packet::VT_LOCAL_IP, local_ip);
  }
  #[inline]
  pub fn add_remote_ip(&mut self, remote_ip: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Packet::VT_REMOTE_IP, remote_ip);
  }
  #[inline]
  pub fn add_local_port(&mut self, local_port: u16) {
    self.fbb_.push_slot::<u16>(Packet::VT_LOCAL_PORT, local_port, 0);
  }
  #[inline]
  pub fn add_remote_port(&mut self, remote_port: u16) {
    self.fbb_.push_slot::<u16>(Packet::VT_REMOTE_PORT, remote_port, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Packet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Packet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Packet");
      ds.field("id", &self.id());
      ds.field("process_id", &self.process_id());
      ds.field("process_path", &self.process_path());
      ds.field("direction", &self.direction());
      ds.field("ip_v6", &self.ip_v6());
      ds.field("protocol", &self.protocol());
      ds.field("local_ip", &self.local_ip());
      ds.field("remote_ip", &self.remote_ip());
      ds.field("local_port", &self.local_port());
      ds.field("remote_port", &self.remote_port());
      ds.finish()
  }
}
pub enum LogLineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogLine<'a> {
  type Inner = LogLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogLine<'a> {
  pub const VT_LINE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LogLineArgs<'args>
  ) -> flatbuffers::WIPOffset<LogLine<'bldr>> {
    let mut builder = LogLineBuilder::new(_fbb);
    if let Some(x) = args.line { builder.add_line(x); }
    builder.finish()
  }


  #[inline]
  pub fn line(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogLine::VT_LINE, None)}
  }
}

impl flatbuffers::Verifiable for LogLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("line", Self::VT_LINE, false)?
     .finish();
    Ok(())
  }
}
pub struct LogLineArgs<'a> {
    pub line: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LogLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogLineArgs {
      line: None,
    }
  }
}

pub struct LogLineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogLineBuilder<'a, 'b> {
  #[inline]
  pub fn add_line(&mut self, line: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogLine::VT_LINE, line);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogLineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogLine");
      ds.field("line", &self.line());
      ds.finish()
  }
}
pub enum InfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Info<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Info<'a> {
  type Inner = Info<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Info<'a> {
  pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Info { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InfoArgs
  ) -> flatbuffers::WIPOffset<Info<'bldr>> {
    let mut builder = InfoBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_value_type(args.value_type);
    builder.finish()
  }


  #[inline]
  pub fn value_type(&self) -> InfoUnion {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<InfoUnion>(Info::VT_VALUE_TYPE, Some(InfoUnion::NONE)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Info::VT_VALUE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_packet(&self) -> Option<Packet<'a>> {
    if self.value_type() == InfoUnion::Packet {
      self.value().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Packet::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_log_line(&self) -> Option<LogLine<'a>> {
    if self.value_type() == InfoUnion::LogLine {
      self.value().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LogLine::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Info<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<InfoUnion, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          InfoUnion::Packet => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Packet>>("InfoUnion::Packet", pos),
          InfoUnion::LogLine => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogLine>>("InfoUnion::LogLine", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct InfoArgs {
    pub value_type: InfoUnion,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for InfoArgs {
  #[inline]
  fn default() -> Self {
    InfoArgs {
      value_type: InfoUnion::NONE,
      value: None,
    }
  }
}

pub struct InfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_value_type(&mut self, value_type: InfoUnion) {
    self.fbb_.push_slot::<InfoUnion>(Info::VT_VALUE_TYPE, value_type, InfoUnion::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Info::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Info<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Info<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Info");
      ds.field("value_type", &self.value_type());
      match self.value_type() {
        InfoUnion::Packet => {
          if let Some(x) = self.value_as_packet() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        InfoUnion::LogLine => {
          if let Some(x) = self.value_as_log_line() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("value", &x)
        },
      };
      ds.finish()
  }
}
pub enum VerdictResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VerdictResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VerdictResponse<'a> {
  type Inner = VerdictResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VerdictResponse<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_VERDICT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VerdictResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VerdictResponseArgs
  ) -> flatbuffers::WIPOffset<VerdictResponse<'bldr>> {
    let mut builder = VerdictResponseBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_verdict(args.verdict);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(VerdictResponse::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn verdict(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(VerdictResponse::VT_VERDICT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for VerdictResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<i8>("verdict", Self::VT_VERDICT, false)?
     .finish();
    Ok(())
  }
}
pub struct VerdictResponseArgs {
    pub id: u64,
    pub verdict: i8,
}
impl<'a> Default for VerdictResponseArgs {
  #[inline]
  fn default() -> Self {
    VerdictResponseArgs {
      id: 0,
      verdict: 0,
    }
  }
}

pub struct VerdictResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VerdictResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(VerdictResponse::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_verdict(&mut self, verdict: i8) {
    self.fbb_.push_slot::<i8>(VerdictResponse::VT_VERDICT, verdict, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VerdictResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VerdictResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VerdictResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VerdictResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VerdictResponse");
      ds.field("id", &self.id());
      ds.field("verdict", &self.verdict());
      ds.finish()
  }
}
pub enum ShutdownOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Shutdown<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Shutdown<'a> {
  type Inner = Shutdown<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Shutdown<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Shutdown { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ShutdownArgs
  ) -> flatbuffers::WIPOffset<Shutdown<'bldr>> {
    let mut builder = ShutdownBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for Shutdown<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ShutdownArgs {
}
impl<'a> Default for ShutdownArgs {
  #[inline]
  fn default() -> Self {
    ShutdownArgs {
    }
  }
}

pub struct ShutdownBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShutdownBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShutdownBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShutdownBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Shutdown<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Shutdown<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Shutdown");
      ds.finish()
  }
}
pub enum CommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Command<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Command<'a> {
  type Inner = Command<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Command<'a> {
  pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Command { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CommandArgs
  ) -> flatbuffers::WIPOffset<Command<'bldr>> {
    let mut builder = CommandBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }


  #[inline]
  pub fn command_type(&self) -> CommandUnion {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CommandUnion>(Command::VT_COMMAND_TYPE, Some(CommandUnion::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Command::VT_COMMAND, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_response(&self) -> Option<VerdictResponse<'a>> {
    if self.command_type() == CommandUnion::Response {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { VerdictResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_shutdown(&self) -> Option<Shutdown<'a>> {
    if self.command_type() == CommandUnion::Shutdown {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Shutdown::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Command<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<CommandUnion, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, false, |key, v, pos| {
        match key {
          CommandUnion::Response => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VerdictResponse>>("CommandUnion::Response", pos),
          CommandUnion::Shutdown => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Shutdown>>("CommandUnion::Shutdown", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct CommandArgs {
    pub command_type: CommandUnion,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CommandArgs {
  #[inline]
  fn default() -> Self {
    CommandArgs {
      command_type: CommandUnion::NONE,
      command: None,
    }
  }
}

pub struct CommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_command_type(&mut self, command_type: CommandUnion) {
    self.fbb_.push_slot::<CommandUnion>(Command::VT_COMMAND_TYPE, command_type, CommandUnion::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Command::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Command<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Command<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Command");
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        CommandUnion::Response => {
          if let Some(x) = self.command_as_response() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        CommandUnion::Shutdown => {
          if let Some(x) = self.command_as_shutdown() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
}  // pub mod Protocol

